DEFINE_UI_PARAMS(blend, Blend, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
DEFINE_UI_PARAMS(seed, Seed, DCTLUI_SLIDER_INT, 1, 1, 200, 1)
DEFINE_UI_PARAMS(pivot, Pivot, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(toe, Toe, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(shoulder, Shoulder, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(black_point, Black Point, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.01)
DEFINE_UI_PARAMS(white_point, White Point, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.01)
DEFINE_UI_PARAMS(pivot_slope, Pivot Slope, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 3.0, 0.01)
DEFINE_UI_PARAMS(show_curve, Show Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(randomize, Randomize, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(ungroup_rgb, Ungroup RGB, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(interpolation, Interpolation, DCTLUI_COMBO_BOX, 0, {CUBIC, QUADRATIC}, {Cubic, Quadratic})


typedef struct {
    float pivot_x, pivot_y;
    float white_x, white_y;
    float black_x, black_y;
    float toe_x, toe_y;
    float shoulder_x, shoulder_y;
    float black_slope;
    float white_slope;
    float pivot_slope;
    float toe, shoulder; // store amount of smoothing.
    float blend;
    int interpolation;
} contrast_params_t;


__DEVICE__ float randu(__PRIVATE__ uint* seed) {
    // Returns random number in interval [0, 1)
    uint old_seed = *seed;
    const uint m = (1 << 31) - 1;
    const uint a = 48271;
    uint new_seed = (a * old_seed) % m;
    *seed = new_seed;
    return (((float) new_seed) / (float) m);
}

__DEVICE__ float randu_bi(__PRIVATE__ uint* seed) {
    // Returns random number in interval (-1, +1)
    return randu(seed) * 2.0 - 1.0;
}

__DEVICE__ inline float3 _max3(float3 x, float3 y) {
    float3 output = make_float3(_fmaxf(x.x, y.x), _fmaxf(x.y, y.y), _fmaxf(x.z, y.z));
    return output;
}

__DEVICE__ float linear_interpolate(float x, float x1, float y1, float x2, float y2) {
    float d = (x - x1) / (x2 - x1);
    float out = d * (y2 - y1) + y1;
    return out;
}

__DEVICE__ float point_slope(float x, float x1, float y1, float m1) {
    return (x - x1) * m1 + y1;
}

__DEVICE__ float point_slope_inv(float y, float x1, float y1, float m1) {
    return (y - y1) / m1 + x1;
}


__DEVICE__ float cubic_interpolate(float x, float x1, float y1, float m1, float x2, float y2, float m2) {
    // https://en.wikipedia.org/wiki/Spline_interpolation#Algorithm_to_find_the_interpolating_cubic_spline
    //
    // Given lines:
    // y = (x - x1) * m1 + y1
    // y = (x - x2) * m2 + y2
    //
    // Computes a cubic function that intersects with (x1, y1) with slope m1, and
    // hits (x2, y2) with slope (m2)
    float t = (x - x1) / (x2 - x1);
    float a = m1 * (x2 - x1) - (y2 - y1);
    float b = -1 * m2 * (x2 - x1) + (y2 - y1);
    float q = (1 - t) * y1 + t * y2 + t * (1 - t) * ((1 - t) * a + t * b);

    float output;
    if ((x1 <= x2 && x >= x2) || (x1 >= x2 && x <= x2)) {
        output = point_slope(x, x2, y2, m2);
    } else if ((x1 <= x2 && x <= x1) || (x1 >= x2 && x >= x1)) {
        output = point_slope(x, x1, y1, m1);
    } else {
        output = q;
    }
    return output;
}


__DEVICE__ float quadratic_interpolate(float x, float x1, float y1, float m1, float x2, float y2, float m2) {
    // Given lines:
    // y = (x - x1) * m1 + y1
    // y = (x - x2) * m2 + y2
    //
    // Computes a quadratic function that intersects with (x1, y1) with slope m1, and then is tangent
    // to line 2.

    float x3, y3;
    x3 = (y2 - y1 + m1 * x1 - m2 * x2) / (m1 - m2);
    y3 = (x3 - x1) * m1 + y1;

    float x1p, y1p, x2p, y2p;

    x1p = x1;
    y1p = y1;

    float a, b, c;
    a = -1.0 * (m1*m1 - 2*m1*m2 + m2*m2)/(4*(y2 - y1p - m2*x2 + m2*x1p));
    b = (2*m1*y2 - 2*m1*y1p + m1*m1*x1p + m2*m2*x1p - 2*m1*m2*x2)/(2*(y2 - y1p - m2*x2 + m2*x1p));
    c = y1p - (a * x1p*x1p) - b*x1p;
    x2p = (m2 - b) / (2*a);
    y2p = (x2p - x2) * m2 + y2;

    // Inflection point
    float inf = -1.0 * b / (2.0 * a);

    float interp = a*x*x + b*x + c;

    float output;
    if ((x1p <= x2p && x >= x2p) || (x1p >= x2p && x <= x2p)) {
        output = point_slope(x, x2, y2, m2);
    } else if ((x1p <= x2p && x <= x1p) || (x1p >= x2p && x >= x1p)) {
        output = point_slope(x, x1, y1, m1);
    } else {
        output = interp;
    }
    return output;
}

__DEVICE__ float render_contrast_simple_quadratic(__PRIVATE__ contrast_params_t* contrast, float x) {
    // piecewise function
    float m1, m2;
    float out;
    if (x < contrast->toe_x) {
        m1 = contrast->black_slope;
        m2 = contrast->pivot_slope;
        if (m1 == m2) {
            out = point_slope(x, contrast->pivot_x, contrast->pivot_y, contrast->pivot_slope);
        } else if (point_slope(contrast->black_x, contrast->pivot_x, contrast->pivot_y, contrast->pivot_slope) > contrast->black_y) {
            // low contrast shadows
            out = quadratic_interpolate(x, contrast->black_x, contrast->black_y, m1, contrast->toe_x, contrast->toe_y, m2);
        } else {
            // high contrast shadows
            out = quadratic_interpolate(x, contrast->toe_x, contrast->toe_y, m2, contrast->black_x, contrast->black_y, m1);
        }
    } else if (contrast->toe_x <= x && x < contrast->shoulder_x) {
        out = linear_interpolate(x, contrast->toe_x, contrast->toe_y, contrast->shoulder_x, contrast->shoulder_y);
    } else if (contrast->shoulder_x <= x) {
        m1 = contrast->pivot_slope;
        m2 = contrast->white_slope;
        if (m1 == m2) {
            out = point_slope(x, contrast->pivot_x, contrast->pivot_y, contrast->pivot_slope);
        } else if (point_slope(contrast->white_x, contrast->pivot_x, contrast->pivot_y, contrast->pivot_slope) < contrast->white_y) {
            // low contrast highlights
            out = quadratic_interpolate(x, contrast->white_x, contrast->white_y, m2, contrast->shoulder_x, contrast->shoulder_y, m1);
        } else {
            // High contrast highlights
            out = quadratic_interpolate(x, contrast->shoulder_x, contrast->shoulder_y, m1, contrast->white_x, contrast->white_y, m2);
        }

    }
    return out;
}


__DEVICE__ float render_contrast_simple_cubic(__PRIVATE__ contrast_params_t* contrast, float x) {
    // piecewise function
    float m1, m2;
    float out;
    if (x < contrast->toe_x) {
        m1 = contrast->black_slope;
        m2 = contrast->pivot_slope;
        out = cubic_interpolate(x, contrast->black_x, contrast->black_y, m1, contrast->toe_x, contrast->toe_y, m2);
    } else if (contrast->toe_x <= x && x < contrast->shoulder_x) {
        out = linear_interpolate(x, contrast->toe_x, contrast->toe_y, contrast->shoulder_x, contrast->shoulder_y);
    } else if (contrast->shoulder_x <= x) {
        m1 = contrast->pivot_slope;
        m2 = contrast->white_slope;
        out = cubic_interpolate(x, contrast->white_x, contrast->white_y, m2, contrast->shoulder_x, contrast->shoulder_y, m1);
    }
    return out;
}

__DEVICE__ float render_contrast(__PRIVATE__ contrast_params_t* contrast, float x) {
    float c;
    if (contrast->interpolation == CUBIC) {
        c = render_contrast_simple_cubic(contrast, x);
    } else if (contrast->interpolation == QUADRATIC) {
        c = render_contrast_simple_quadratic(contrast, x);
    }
    float output = _mix(x, c, contrast->blend);
    return output;
}

__DEVICE__ float3 render_contrast_3ch(__PRIVATE__ contrast_params_t* contrast_r, __PRIVATE__ contrast_params_t* contrast_g, __PRIVATE__ contrast_params_t* contrast_b, float3 c) {
    c.x = render_contrast(contrast_r, c.x);
    c.y = render_contrast(contrast_g, c.y);
    c.z = render_contrast(contrast_b, c.z);
    return c;
}

__DEVICE__ float3 draw_contrast_curve(__PRIVATE__ contrast_params_t* contrast_r, __PRIVATE__ contrast_params_t* contrast_g, __PRIVATE__ contrast_params_t* contrast_b, float x, float y, float3 curr_color) {
    float3 y_val = render_contrast_3ch(contrast_r, contrast_g, contrast_b, make_float3(x, x, x));
    float3 output_color = curr_color;
    float3 diff = make_float3(_fabs(y_val.x - y), _fabs(y_val.y - y), _fabs(y_val.z - y));
    if (diff.x <= 0.002) {
        output_color = _max3(output_color, make_float3(1.0, 0.0, 0.0));
    }
    if (diff.y <= 0.002) {
        output_color = _max3(output_color, make_float3(0.0, 1.0, 0.0));
    }
    if (diff.z <= 0.002) {
        output_color = _max3(output_color, make_float3(0.0, 0.0, 1.0));
    }
    return output_color;
}

__DEVICE__ float3 draw_grid_lines(float x, float y, float3 curr_color) {
    float major_line_x = _fabs(_fmod(x + 0.1, 0.2) - 0.1);
    float minor_line_x = _fabs(_fmod(x + 0.02, 1.0 / 25.0) - 0.02);
    float major_line_y = _fabs(_fmod(y + 0.1, 0.2) - 0.1);
    float minor_line_y = _fabs(_fmod(y + 0.02, 1.0 / 25.0) - 0.02);

    float3 output_color = curr_color;
    if (0 < x && x < 1.0 && 0 < y && y < 1.0 && (major_line_x <= 0.002 || major_line_y <= 0.002)) {
        output_color += 0.1;
    }
    if (0 < x && x < 1.0 && 0 < y && y < 1.0 && (minor_line_x <= 0.001 || minor_line_y <= 0.001)) {
        output_color += 0.05;
    }
    return output_color;
}
__DEVICE__ void randomize_contrast(__PRIVATE__ contrast_params_t* params, __PRIVATE__ uint* seed) {
    params->black_y += randu_bi(seed) * 0.2;
    params->white_y += randu_bi(seed) * 0.2;
    params->pivot_slope += randu_bi(seed) * 0.4;
    params->toe += randu_bi(seed) * 0.4;
    params->shoulder += randu_bi(seed) * 0.2;

    params->toe = _saturatef(params->toe);
    params->shoulder = _saturatef(params->shoulder);
}

__DEVICE__ void unify_rgb_contrasts(__PRIVATE__ contrast_params_t* params_r, __PRIVATE__ contrast_params_t* params_g, __PRIVATE__ contrast_params_t* params_b) {
    // Unify black point and white point
    params_g->black_y = params_r->black_y;
    params_b->black_y = params_r->black_y;

    params_g->white_y = params_r->white_y;
    params_b->white_y = params_r->white_y;

    // params_g->toe = params_r->toe;
    // params_b->toe = params_r->toe;

    // params_g->shoulder = params_r->shoulder;
    // params_b->shoulder = params_r->shoulder;

    // params_g->pivot_slope = params_r->pivot_slope;
    // params_b->pivot_slope = params_r->pivot_slope;

}

__DEVICE__ void compute_toe_shoulder_cubic(__PRIVATE__ contrast_params_t* params) {

    if (point_slope(params->white_x, params->pivot_x, params->pivot_y, params->pivot_slope) <= params->white_y) {
        // Low contrast, highlights.
        params->shoulder_x = _mix(params->pivot_x, params->white_x, params->shoulder);
        params->shoulder_y = point_slope(params->shoulder_x, params->pivot_x, params->pivot_y, params->pivot_slope);
        params->white_slope = _powf((params->white_y - params->shoulder_y) / (params->white_x - params->shoulder_x), 2.0);
    } else {
        // High contrast, highlights
        params->shoulder_y = _mix(params->pivot_y, params->white_y, params->shoulder);
        params->shoulder_x = point_slope_inv(params->shoulder_y, params->pivot_x, params->pivot_y, params->pivot_slope);
        params->white_slope = _powf((params->white_y - params->shoulder_y) / (params->white_x - params->shoulder_x), 2.0);
    }

    if (point_slope(params->black_x, params->pivot_x, params->pivot_y, params->pivot_slope) >= params->black_y) {
        // Low contrast, shadows
        params->toe_x = _mix(params->pivot_x, params->black_x, params->toe);
        params->toe_y = point_slope(params->toe_x, params->pivot_x, params->pivot_y, params->pivot_slope);
        params->black_slope = _powf((params->black_y - params->toe_y) / (params->black_x - params->toe_x), 2.0);
    } else {
        params->toe_y = _mix(params->pivot_y, params->black_y, params->toe);
        params->toe_x = point_slope_inv(params->toe_y, params->pivot_x, params->pivot_y, params->pivot_slope);
        params->black_slope = _powf((params->black_y - params->toe_y) / (params->black_x - params->toe_x), 2.0);
    }
}


__DEVICE__ void compute_toe_shoulder_quadratic(__PRIVATE__ contrast_params_t* params) {

    if (point_slope(params->white_x, params->pivot_x, params->pivot_y, params->pivot_slope) <= params->white_y) {
        // Low contrast, highlights.
        params->shoulder_x = _mix(params->pivot_x, params->white_x, params->shoulder);
        params->shoulder_y = point_slope(params->shoulder_x, params->pivot_x, params->pivot_y, params->pivot_slope);
        params->white_slope = 2.0 * (params->white_y - params->shoulder_y) / (params->white_x - params->shoulder_x);
    } else {
        // High contrast, highlights
        params->shoulder_y = _mix(params->pivot_y, params->white_y, params->shoulder);
        params->shoulder_x = point_slope_inv(params->shoulder_y, params->pivot_x, params->pivot_y, params->pivot_slope);
        params->white_slope = 0.5 * (params->white_y - params->shoulder_y) / (params->white_x - params->shoulder_x);
    }

    if (point_slope(params->black_x, params->pivot_x, params->pivot_y, params->pivot_slope) >= params->black_y) {
        // Low contrast, shadows
        params->toe_x = _mix(params->pivot_x, params->black_x, params->toe);
        params->toe_y = point_slope(params->toe_x, params->pivot_x, params->pivot_y, params->pivot_slope);
        params->black_slope = 2.0 * (params->black_y - params->toe_y) / (params->black_x - params->toe_x);
    } else {
        params->toe_y = _mix(params->pivot_y, params->black_y, params->toe);
        params->toe_x = point_slope_inv(params->toe_y, params->pivot_x, params->pivot_y, params->pivot_slope);
        params->black_slope = 0.5 * (params->black_y - params->toe_y) / (params->black_x - params->toe_x);
    }
}

__DEVICE__ void compute_toe_shoulder(__PRIVATE__ contrast_params_t* params) {
    if (params->interpolation == CUBIC) {
        compute_toe_shoulder_cubic(params);
    } else if (params->interpolation == QUADRATIC) {
        compute_toe_shoulder_quadratic(params);
    }
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    uint state = seed;
    randu(&state);

    contrast_params_t params;
    params.pivot_x = pivot;
    params.pivot_y = pivot;
    params.black_x = 0.0;
    params.black_y = black_point;
    params.white_x = 1.0;
    params.white_y = white_point;
    params.pivot_slope = pivot_slope;
    params.toe = toe;
    params.shoulder = shoulder;
    params.blend = blend;
    params.interpolation = interpolation;

    contrast_params_t params_r = params;
    contrast_params_t params_g = params;
    contrast_params_t params_b = params;
    if (randomize && ungroup_rgb) {
        randomize_contrast(&params_r, &state);
        randomize_contrast(&params_g, &state);
        randomize_contrast(&params_b, &state);
        unify_rgb_contrasts(&params_r, &params_g, &params_b);

    } else if (randomize) {
        randomize_contrast(&params_r, &state);
        params_g = params_r;
        params_b = params_r;
    }

    compute_toe_shoulder(&params_r);
    compute_toe_shoulder(&params_g);
    compute_toe_shoulder(&params_b);


    float3 curr_color = make_float3(p_R, p_G, p_B);
    float3 output_color = render_contrast_3ch(&params_r, &params_g, &params_b, curr_color);

    // Drawing grid lines and the contrast curve.
    float x = (float)p_X / p_Width;
    x = (x - 0.5) * p_Width / p_Height + 0.5;
    float y = 1.0 - (float)p_Y / p_Height;
    if (show_curve) {
        float3 curve_line = draw_contrast_curve(&params_r, &params_g, &params_b, x, y, output_color);
        float3 grid_line = draw_grid_lines(x, y, output_color);
        output_color = _max3(curve_line, grid_line);
    }

    return output_color;
}