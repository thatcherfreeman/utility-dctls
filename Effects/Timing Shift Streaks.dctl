#line 2

// clang-format off
DEFINE_UI_PARAMS(length, Length, DCTLUI_SLIDER_FLOAT, 0.1, 0.0, 0.5, 0.001)
DEFINE_UI_PARAMS(opacity_stops, Streak Exposure, DCTLUI_SLIDER_FLOAT, -2.0, -8.0, 0.0, 0.001)
DEFINE_UI_PARAMS(jitter_length, Jitter Length, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0f, 0.001)
DEFINE_UI_PARAMS(jitter_exposure, Jitter Exposure, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0f, 0.001)
DEFINE_UI_PARAMS(falloff, Falloff, DCTLUI_COMBO_BOX, 0, {FALLOFF_COSINE1, FALLOFF_COSINE2, FALLOFF_LINEAR, FALLOFF_BOX, FALLOFF_GAUSSIAN}, {Cosine 1, Cosine 2, Linear, Box, Gaussian})
DEFINE_UI_PARAMS(direction, Direction, DCTLUI_COMBO_BOX, 0, {DIRECTION_UP, DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT}, {Up, Down, Left, Right})
// clang-format on

__DEVICE__ float powf(float base, float exp) {
    return _copysignf(_powf(_fabs(base), exp), base);
}

/////////////////////////////////////////////
// PDFs and CDFs
/////////////////////////////////////////////

__DEVICE__ float standard_norm_cdf(float z) {
    // Approximation of Normal CDF function with mean 0 and var 1.
    const float k = _sqrtf(2.0f / 3.1415926535f);
    float output = 1.0f / (1.0f + _expf(-2.0f * k * z));
    return output;
}

__DEVICE__ float norm_cdf(float z, float mean, float var) {
    float output = standard_norm_cdf((z - mean) / _sqrtf(var));
    return output;
}

__DEVICE__ float standard_norm_inv_cdf(float z) {
    // Approximation from "Very Simply Explicitly Invertible Approximations of
    // Normal Cumulative and Normal Quantile Function" by Alessandro Soranzo

    // CDF
    // float out = _powf(2.0, -1.0 * _powf(22, 1 - _powf(41, z / 10.0)));
    float abs_z = _fabs(z - 0.5f) + 0.5f;
    float out = 10.0f / _logf(41.0f) * _logf(1.0f - (_logf((-1.0f * _logf(abs_z)) / _logf(2.0f))) / _logf(22.0f));
    if (abs_z >= 0.995f) {
        out = 2.5758f;
    }

    if (z <= 0.5f) {
        out *= -1.0f;
    }
    return out;
}

__DEVICE__ float norm_inv_cdf(float z, float mean, float var) {
    float out = standard_norm_inv_cdf(z) * _sqrtf(var) + mean;
    return out;
}

__DEVICE__ float norm_pdf(float z, float mean, float var) {
    float out = _expf(-0.5f * (z - mean) * (z - mean) / var);
    out *= 1.0f / (_sqrtf(2.0f * 3.1415926535f * var));
    return out;
}

/////////////////////////////////////////////
// Random Number Generator
/////////////////////////////////////////////

typedef uint rand_state;

__DEVICE__ float _randu_lcg(__PRIVATE__ rand_state* seed) {
    // Returns random number in interval [0, 1)
    rand_state old_seed = *seed;
    const rand_state m = (~((rand_state)0));
    const rand_state a = 48271;
    rand_state new_seed = (a * old_seed) % m;
    *seed = new_seed;
    return (((float)new_seed) / (float)m);
}

__DEVICE__ float _randu_xorshift(__PRIVATE__ rand_state* seed) {
    rand_state x = *seed;
    x ^= (x << 13 | x >> 19);
    x ^= (x >> 7 | x << 25);
    x ^= (x << 15 | x >> 15);
    *seed = x;
    return (((float)x) / (float)(~((rand_state)0)));
}

__DEVICE__ inline float randu(__PRIVATE__ rand_state* seed) {
    return _randu_xorshift(seed);
}

/////////////////////////////////////////////
// Distribution Sampling functions
/////////////////////////////////////////////

__DEVICE__ float sample_uniform(float a, float b, __PRIVATE__ rand_state* seed) {
    float range = b - a;
    float x = randu(seed);
    return a + range * x;
}

__DEVICE__ float sample_norm(float mean, float var, __PRIVATE__ rand_state* seed) {
    float u_sample = randu(seed);
    float out = norm_inv_cdf(u_sample, mean, var);
    return out;
}

// Falloff functions

__DEVICE__ float linear_falloff(float r, float length) {
    return _mix(1.0f, 0.0f, _clampf(r / length, 0.0f, 1.0f));
}

__DEVICE__ float box_falloff(float r, float length) {
    if (r < length) {
        return 1.0f;
    }
    return 0.0f;
}

__DEVICE__ float gaussian_falloff(float r, float length) {
    return _expf(-6.0f * r * r / (length * length));
}

__DEVICE__ float cosine1_falloff(float r, float length) {
    return (_cosf(_clampf(r / length, 0.0f, 1.0f) * (3.14159265f)) + 1.0f) * 0.5f;
}

__DEVICE__ float cosine2_falloff(float r, float length) {
    return _cosf(_clampf(r / length, 0.0f, 1.0f) * (3.14159265f / 2.0f));
}

__DEVICE__ float falloff_switcher(float r, float length, int falloff_type) {
    if (falloff_type == FALLOFF_LINEAR) {
        return linear_falloff(r, length);
    } else if (falloff_type == FALLOFF_BOX) {
        return box_falloff(r, length);
    } else if (falloff_type == FALLOFF_GAUSSIAN) {
        return gaussian_falloff(r, length);
    } else if (falloff_type == FALLOFF_COSINE1) {
        return cosine1_falloff(r, length);
    } else if (falloff_type == FALLOFF_COSINE2) {
        return cosine2_falloff(r, length);
    }
    return 0.0f;
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB) {

    float3 input_color = make_float3(_tex2D(p_TexR, p_X, p_Y), _tex2D(p_TexG, p_X, p_Y), _tex2D(p_TexB, p_X, p_Y));

    // Initialize random number generator
    float seed = TIMELINE_FRAME_INDEX;
    rand_state state_value = *((__PRIVATE__ rand_state*)&seed);
    __PRIVATE__ rand_state* state = &state_value;
    float val;
    val = randu(state);
    val = randu(state);
    val = randu(state);
    val = randu(state);
    *state = *((__PRIVATE__ rand_state*)&val);

    float random_value = sample_norm(0.0f, 1.0f, state);

    float shorter_dim = _fminf((float)p_Width, (float)p_Height);
    float pixel_length = length * _fmaxf(0.0f, (1.0f + 0.10f * jitter_length * random_value)) * shorter_dim;

    int start_x, start_y;
    start_x = p_X;
    start_y = p_Y;
    int end_x, end_y;
    end_x = start_x;
    end_y = start_y;

    if (direction == DIRECTION_UP) {
        end_x = p_X;
        end_y = p_Y + (int)pixel_length;
    } else if (direction == DIRECTION_DOWN) {
        end_x = p_X;
        start_y = p_Y - (int)pixel_length;
    } else if (direction == DIRECTION_LEFT) {
        end_x = p_X + (int)pixel_length;
        end_y = p_Y;
    } else if (direction == DIRECTION_RIGHT) {
        start_x = p_X - (int)pixel_length;
        end_y = p_Y;
    }

    float total_weight = 0.0f;
    float3 blurred_color = make_float3(0.0f, 0.0f, 0.0f);
    for (int i = start_x; i <= end_x; ++i) {
        for (int j = start_y; j <= end_y; ++j) {
            float dist = _fabs((float)((i - p_X) + (j - p_Y))); // Assume to only have vertical or horizontal component.
            float falloff_value = falloff_switcher(dist, pixel_length, falloff);
            float3 sample_color = make_float3(_tex2D(p_TexR, i, j), _tex2D(p_TexG, i, j), _tex2D(p_TexB, i, j));
            total_weight += falloff_value;
            blurred_color += sample_color * falloff_value;
        }
    }

    blurred_color /= total_weight;
    float opacity = _fminf(_exp2f(opacity_stops + random_value * 0.10f * jitter_exposure), 1.0f);
    float3 result_color = input_color * (1.0f - opacity) + blurred_color * opacity;
    return result_color;
}