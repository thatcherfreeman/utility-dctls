FuRegisterClass("DCTLInterpreter", CT_Tool, {
    REGS_Name = "DCTLInterpreter",
    REGS_Category = "Fuses\\Util",
    REGS_OpIconString = "DCTLi",
    REGS_OpDescription = "Open a DCTL and run it in a Fuse."
})

-- UTILITY FUNCTIONS --
function sleep()
    local j = 0
    for i = 1, 1000000000 do
        j = j + 1
    end
end
function table_len(t)
    local counter = 0
    for k, v in pairs(t) do
        counter = counter + 1
    end
    return counter
end


function print_table(t, indentation)
    if indentation == nil then
        indentation = 0
    end
    local outer_prefix = string.rep("    ", indentation)
    local inner_prefix = string.rep("    ", indentation + 1)
    print(outer_prefix, "{")
    for k, v in pairs(t) do
        if type(v) == "table" then
            print(inner_prefix, k, ": ")
            print_table(v, indentation + 1)
        elseif type(v) == "string" then
            print(inner_prefix, k, string.format([[: "%s"]], v))
        else
            print(inner_prefix, k, ": ", v)
        end
    end
    print(outer_prefix, "}")
end

function dump(o)
    if type(o) == 'table' then
        local s = '{ '
        for k, v in pairs(o) do
            if type(k) ~= 'number' then
                k = '"' .. k .. '"'
            end
            s = s .. '[' .. k .. '] = ' .. dump(v) .. ','
        end
        return s .. '} '
    else
        return tostring(o)
    end
end

function string.insert(str1, str2, pos)
    return str1:sub(1, pos) .. str2 .. str1:sub(pos + 1)
end
function string.trim(s)
    return (s:gsub("^%s*(.-)%s*$", "%1"))
end

function Create()
    -- Globals
    PreviousFn = ""
    -- Default value for all sliders, needs to be a number users aren't likely to enter themselves in nature. Chosen at random.
    MAGIC_DEFAULT = -420691

    -- Inputs
    ResetParamsButton = self:AddInput("Reset Parameters", "ResetParameters", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ButtonControl",
        INP_DoNotifyChanged = true,
        INP_External = false,
        INPS_StatusText = "Reset the arguments of the chosen DCTL to their defaults.",
    })

    DCTLFile = self:AddInput("DCTL File", "DCTLFile", {
        LINKID_DataType = "Text",
        INPID_InputControl = "FileControl",
        FC_ClipBrowse = false,
        FC_IsSaver = false,
        FC_PathBrowse = false,
        FCS_FilterString = "DCTL Files (*.dctl)|*.dctl|",
        INP_DoNotifyChanged = true,
        INP_ForceNotify = false,
        INP_InitialNotify = true,
        INPS_StatusText = "Select your DCTL here.",
    })

    -- DCTL PARAMETERS
    local num_sliders = 64
    InpFloatSliders = {}
    for i = 0, num_sliders - 1 do
        InpFloatSliders[i] = self:AddInput(string.format("Float Slider %d", i), string.format("FloatSlider%d", i), {
            LINKID_DataType = "Number",
            INPID_InputControl = "SliderControl",
            INP_MinScale = 0.0,
            INP_MaxScale = 10.0,
            INP_Default = MAGIC_DEFAULT,
            IC_Visible = false
        })
    end
    InpIntSliders = {}
    for i = 0, num_sliders - 1 do
        InpIntSliders[i] = self:AddInput(string.format("Int Slider %d", i), string.format("IntSlider%d", i), {
            LINKID_DataType = "Number",
            INPID_InputControl = "SliderControl",
            INP_MinScale = 0.0,
            INP_MaxScale = 10.0,
            INP_Default = MAGIC_DEFAULT,
            IC_Visible = false,
            INP_Integer = true
        })
    end
    InpValueBoxes = {}
    for i = 0, num_sliders - 1 do
        InpValueBoxes[i] = self:AddInput(string.format("Value Box %d", i), string.format("ValueBox%d", i), {
            LINKID_DataType = "Number",
            INPID_InputControl = "ScrewControl",
            INP_Default = MAGIC_DEFAULT,
            IC_Visible = false
        })
    end
    InpCheckBoxes = {}
    for i = 0, num_sliders - 1 do
        InpCheckBoxes[i] = self:AddInput(string.format("Check Box %d", i), string.format("CheckBox%d", i), {
            LINKID_DataType = "Number",
            INPID_InputControl = "CheckboxControl",
            INP_Default = MAGIC_DEFAULT,
            INP_Integer = true,
            IC_Visible = false
        })
    end
    InpComboBoxes = {}
    for i = 0, num_sliders - 1 do
        InpComboBoxes[i] = self:AddInput(string.format("Combo Box %d", i), string.format("ComboBox%d", i), {
            LINKID_DataType = "Number",
            INPID_InputControl = "ComboControl",
            INP_Default = MAGIC_DEFAULT,
            INP_Integer = true,
            IC_Visible = false
        })
    end
    InpColorControlReds = {}
    InpColorControlGreens = {}
    InpColorControlBlues = {}
    for i = 0, num_sliders - 1 do
        InpColorControlReds[i] = self:AddInput(string.format("Color Picker Red %d", i),
            string.format("ColorPickerRed%d", i), {
                ICS_Name = string.format("Color %d", i),
                LINKID_DataType = "Number",
                INPID_InputControl = "ColorControl",
                CLRC_ShowWheel = false,
                INP_Default = MAGIC_DEFAULT,
                IC_ControlGroup = i+1,
                IC_ControlID = 0,
                IC_Visible = false
            })
        InpColorControlGreens[i] = self:AddInput(string.format("Color Picker Green %d", i),
            string.format("ColorPickerGreen%d", i), {
                LINKID_DataType = "Number",
                INPID_InputControl = "ColorControl",
                INP_Default = MAGIC_DEFAULT,
                IC_ControlGroup = i+1,
                IC_ControlID = 1,
                IC_Visible = false
            })
        InpColorControlBlues[i] = self:AddInput(string.format("Color Picker Blue %d", i),
            string.format("ColorPickerBlue%d", i), {
                LINKID_DataType = "Number",
                INPID_InputControl = "ColorControl",
                INP_Default = MAGIC_DEFAULT,
                IC_ControlGroup = i+1,
                IC_ControlID = 2,
                IC_Visible = false
            })
    end

    -- DEBUG PARAMETERS
    self:BeginControlNest("Debug", "Debug", false, {})
    DebugBox = self:AddInput("Debug to Console", "DebugConsole", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INP_Integer = true,
        IC_Visible = true,
        INPS_StatusText = "Prints out the new source code and other information to the console."
    })
    AutoTypecast = self:AddInput("Explicitly Typecast Builtin Funcs", "AutoTypecast", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INP_Integer = true,
        IC_Visible = true,
        INPS_StatusText = "If your DCTL build fails, try checking this box. There is a playback performance penalty though."
    })
    DontRun = self:AddInput("Don't Run the DCTL Code", "DontRun", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INP_Integer = true,
        IC_Visible = true,
        INPS_StatusText = "Rewrites your source code but skips the DCTL running step."
    })
    self:EndControlNest()
    InImage = self:AddInput("Input", "ImageInput", {
        LINKID_DataType = "Image",
        LINK_Main = 1
    })
    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1
    })
end

function OpenDCTL(filename)
    local file_obj = io.open(filename, "r")
    if file_obj == nil then
        print("ERROR: Could not read file ", filename)
    end
    local original_content = file_obj:read("*a")
    file_obj:close()
    return original_content
end

function StripComments(text)
    local text = string.gsub(text, "//.-\n", "\n")
    text = string.gsub(text, "//.-$", "")
    text = string.gsub(text, "/%*.-%*/", "")
    return text
end

function StripACESParams(text)
    local text = string.gsub(text, "DEFINE_ACES_PARAM%(%s*IS_PARAMETRIC_ACES_TRANSFORM%s*%:%s*0%)", "")
    return text
end

function IsAlphaStraight(text)
    local is_straight = string.find(text, "DEFINE_DCTL_ALPHA_MODE_STRAIGHT") ~= nil
    -- Remove occurrences of this flag because they're not real code.
    local text = string.gsub(text, "DEFINE_DCTL_ALPHA_MODE_STRAIGHT", "")
    text = string.gsub(text, "DEFINE_DCTL_ALPHA_MODE_PREMULTIPLY", "")
    return text, is_straight
end

function OpenAndStripDCTL(filename)
    local dctl_contents = OpenDCTL(filename)
    local out_content = StripComments(dctl_contents)
    out_content = StripACESParams(out_content)
    local is_straight_alpha
    out_content, is_straight_alpha = IsAlphaStraight(out_content)

    -- Handle .h files.
    -- * Basically just need to identify the file name, open the file and paste it in.
    -- NOTE: Doesn't enforce that .h files can't have parameters.
    local _, _, starting_directory = string.find(filename, "(.*[/\\])")
    local ret1, h_fn
    local rhs = 0
    local include_pattern = "%#include%s+\"([^\"]*%.h)%\""
    repeat
        ret1, rhs, h_fn = string.find(out_content, include_pattern, rhs)
        if ret1 ~= nil then
            if starting_directory == nil then
                print("ERROR: Found #include statement but cannot parse the working directory for path ", filename)
                break
            end
            local header_contents, header_is_straight_alpha = OpenAndStripDCTL(starting_directory .. h_fn)
            -- Insert the contents of the .h file immediately after the include
            -- statement so that it can be read as well.
            out_content = string.insert(out_content, header_contents, rhs)
            is_straight_alpha = is_straight_alpha or header_is_straight_alpha
        end
    until (ret1 == nil)
    out_content = string.gsub(out_content, include_pattern, "")
    if string.find(out_content, "%#include") ~= nil then
        print("ERROR: Could not parse all #include statements.")
    end

    return out_content, is_straight_alpha
end

function ExtractParameters(dctl_source)
    -- returns Success, the resulting source code, and the parameters.
    local params = {}
    local success = true

    local var_name, label, default_val, min_val, max_val, step_size, enum_list, label_list

    -- FLOAT SLIDERS
    local float_sliders = {}
    local slider_float_pattern =
        "DEFINE_UI_PARAMS%(%s*(%S+)%s*,%s*(%S[^,]*),%s*DCTLUI_SLIDER_FLOAT%s*,%s*([%-%d%.eE]+)f?%s*,%s*([%-%d%.eE]+)f?%s*,%s*([%-%d%.eE]+)f?%s*,%s*([%-%d%.eE]+)f?%s*%)"
    local ret1 = 0
    local rhs = 0
    local slider_float_counter = 0
    repeat
        ret1, rhs, var_name, label, default_val, min_val, max_val, step_size = string.find(dctl_source,
            slider_float_pattern, rhs)
        if ret1 ~= nil then
            float_sliders[slider_float_counter] = {
                param_type = "SLIDER_FLOAT",
                var_name = var_name,
                label = label,
                default_val = tonumber(default_val),
                min_val = tonumber(min_val),
                max_val = tonumber(max_val),
                step_size = tonumber(step_size)
            }
            slider_float_counter = slider_float_counter + 1
        end
    until (ret1 == nil)
    params.float_sliders = float_sliders
    dctl_source = string.gsub(dctl_source, slider_float_pattern, "")

    -- INT SLIDERS
    local int_sliders = {}
    local slider_int_pattern =
        "DEFINE_UI_PARAMS%(%s*(%S+)%s*,%s*(%S[^,]*),%s*DCTLUI_SLIDER_INT%s*,%s*([%-%d]+)%s*,%s*([%-%d]+)%s*,%s*([%-%d]+)%s*,%s*([%-%d]+)%s*%)"
    local ret1 = 0
    local rhs = 0
    local slider_int_counter = 0
    repeat
        ret1, rhs, var_name, label, default_val, min_val, max_val, step_size = string.find(dctl_source,
            slider_int_pattern, rhs)
        if ret1 ~= nil then
            int_sliders[slider_int_counter] = {
                param_type = "SLIDER_INT",
                var_name = var_name,
                label = label,
                default_val = tonumber(default_val),
                min_val = tonumber(min_val),
                max_val = tonumber(max_val),
                step_size = tonumber(step_size)
            }
            slider_int_counter = slider_int_counter + 1
        end
    until (ret1 == nil)
    params.int_sliders = int_sliders
    dctl_source = string.gsub(dctl_source, slider_int_pattern, "")

    -- VALUE BOXES
    local value_boxes = {}
    local value_box_pattern = "DEFINE_UI_PARAMS%(%s*(%S+)%s*,%s*(%S[^,]*),%s*DCTLUI_VALUE_BOX%s*,%s*([%-%d%.eE]+)f?%s*%)"
    local ret1 = 0
    local rhs = 0
    local value_box_counter = 0
    repeat
        ret1, rhs, var_name, label, default_val = string.find(dctl_source, value_box_pattern, rhs)
        if ret1 ~= nil then
            value_boxes[value_box_counter] = {
                param_type = "VALUE_BOX",
                var_name = var_name,
                label = label,
                default_val = tonumber(default_val)
            }
            value_box_counter = value_box_counter + 1
        end
    until (ret1 == nil)
    params.value_boxes = value_boxes
    dctl_source = string.gsub(dctl_source, value_box_pattern, "")

    -- CHECK BOXES
    local check_boxes = {}
    local check_box_pattern = "DEFINE_UI_PARAMS%(%s*(%S+)%s*,%s*(%S[^,]*),%s*DCTLUI_CHECK_BOX%s*,%s*([01])%s*%)"
    local ret1 = 0
    local rhs = 0
    local check_box_counter = 0
    repeat
        ret1, rhs, var_name, label, default_val = string.find(dctl_source, check_box_pattern, rhs)
        if ret1 ~= nil then
            check_boxes[check_box_counter] = {
                param_type = "CHECK_BOX",
                var_name = var_name,
                label = label,
                default_val = tonumber(default_val)
            }
            check_box_counter = check_box_counter + 1
        end
    until (ret1 == nil)
    params.check_boxes = check_boxes
    dctl_source = string.gsub(dctl_source, check_box_pattern, "")

    -- COMBO BOXES
    local combo_boxes = {}
    local combo_box_pattern =
        "DEFINE_UI_PARAMS%(%s*(%S+)%s*,%s*(%S[^,]*),%s*DCTLUI_COMBO_BOX%s*,%s*([%d]+)%s*,%s*{(.-)}%s*,%s*{(.-)}%s*%)"
    local ret1 = 0
    local rhs = 0
    local combo_box_counter = 0
    local enum_block = "\n"
    repeat
        ret1, rhs, var_name, label, default_val, enum_list, label_list =
            string.find(dctl_source, combo_box_pattern, rhs)
        if ret1 ~= nil then
            -- Replace this DEFINE with new #define statements to instantiate the enums.
            local enum_counter = 0
            local enum_table = {}
            for enum_name in string.gmatch(enum_list, "([^,%s]+)") do
                table.insert(enum_table, enum_name)
                enum_counter = enum_counter + 1
            end
            -- Get attributes
            local dropdown_options = {}
            for enum_label in string.gmatch(label_list, "%s*(%S[^,]*)%s*,?") do
                table.insert(dropdown_options, {
                    CCS_AddString = enum_label
                })
            end
            if table_len(dropdown_options) ~= enum_counter then
                print(string.format("ERROR: Mismatched quantity of enums for combo box: %s", label))
                success = false
            end
            combo_boxes[combo_box_counter] = {
                param_type = "COMBO_BOX",
                var_name = var_name,
                label = label,
                default_val = tonumber(default_val),
                dropdown_options = dropdown_options
            }
            combo_box_counter = combo_box_counter + 1
            enum_block = enum_block .. string.format("enum {%s};\n", table.concat(enum_table, ", "))
        end
    until (ret1 == nil)
    dctl_source = string.insert(dctl_source, enum_block, 0)
    params.combo_boxes = combo_boxes
    dctl_source = string.gsub(dctl_source, combo_box_pattern, "")

    -- COLOR PICKERS
    local color_pickers = {}
    local color_picker_pattern =
        "DEFINE_UI_PARAMS%(%s*(%S+)%s*,%s*(%S[^,]*),%s*DCTLUI_COLOR_PICKER%s*,%s*([%-%d%.eE]+)f?%s*,%s*([%-%d%.eE]+)f?%s*,%s*([%-%d%.eE]+)f?%s*%)"
    local ret1 = 0
    local rhs = 0
    local color_picker_counter = 0
    repeat
        ret1, rhs, var_name, label, red_default, green_default, blue_default = string.find(dctl_source,
            color_picker_pattern, rhs)
        if ret1 ~= nil then
            color_pickers[color_picker_counter] = {
                param_type = "COLOR_PICKER",
                var_name = var_name,
                label = label,
                red_default = tonumber(red_default),
                green_default = tonumber(green_default),
                blue_default = tonumber(blue_default)
            }
            color_picker_counter = color_picker_counter + 1
        end
    until (ret1 == nil)
    params.color_pickers = color_pickers
    dctl_source = string.gsub(dctl_source, color_picker_pattern, "")

    -- Tooltips
    local tooltip_pattern = 'DEFINE_UI_TOOLTIP%(%s*(%S[^,]*),%s*(%b"")%)'
    local tooltips = {}
    local ret1 = 0
    repeat
        ret1, rhs, var_name, tooltip_text = string.find(dctl_source, tooltip_pattern, rhs)
        if ret1 ~= nil then
            tooltip_text = tooltip_text:match('^"(.*)"$')
            tooltips[var_name] = tooltip_text
        end
    until (ret1 == nil)
    params.tooltips = tooltips
    dctl_source = string.gsub(dctl_source, tooltip_pattern, "")

    -- Check to make sure we got all the DEFINE_UI_PARAMS.
    rhs = 0
    repeat
        idx, rhs, match = string.find(dctl_source, "DEFINE_UI_PARAMS(%b())", rhs)
        if idx ~= nil then
            success = false
            print(string.format("ERROR: Did not parse: DEFINE_UI_PARAMS%s", match))
        end
    until idx == nil

    return success, dctl_source, params
end

-- Update Default value. If the current value of the parameter is equal
-- to the old default, then we also update the current value of the parameter
-- to be equal to the new default too.
function UpdateDefault(inp, new_default, time)
    -- Inputs that are animated often have a nil GetSource value. Let's
    -- not override the current value when that's the case.
    if (inp:GetSource(time) ~= nil) then
        local curr_value = inp:GetSource(time).Value
        local curr_default = inp:GetAttr("INP_Default")
        if curr_value == curr_default then
            inp:SetSource(Number(new_default), time)
        end
        -- Otherwise, just keep the existing value.
    end
    inp:SetAttrs({
        INP_Default = new_default
    })
end

function HideUIElements(Inputs)
    for i, obj in pairs(Inputs) do
        obj[i]:SetAttrs({
            IC_Visible = false,
            INP_Default = MAGIC_DEFAULT
        })
    end
end

function NotifyChanged(inp, param, time)
    local reset_params = ((inp == DCTLFile) and (PreviousFn ~= param.Value) and (PreviousFn ~= nil) and
                             (PreviousFn ~= "")) or ((inp == ResetParamsButton) and param.Value == 1)

    if (inp == DCTLFile) or ((inp == ResetParamsButton) and (param.Value == 1)) then
        HideUIElements(InpFloatSliders)
        HideUIElements(InpIntSliders)
        HideUIElements(InpValueBoxes)
        HideUIElements(InpCheckBoxes)
        HideUIElements(InpComboBoxes)
        HideUIElements(InpColorControlReds)
        HideUIElements(InpColorControlGreens)
        HideUIElements(InpColorControlBlues)

        local reload_params = (reset_params and (DCTLFile:GetSource(time) ~= "")) or
                                  ((inp == DCTLFile) and (param.Value ~= nil) and (param.Value ~= ""))

        if reload_params then
            -- When new DCTL is loaded in, we need to update the displayed parameters.
            local dctl_file = ""
            if (inp == DCTLFile) then
                dctl_fn = param.Value
            elseif (inp == ResetParamsButton) then
                dctl_fn = DCTLFile:GetSource(time).Value
            end
            local content, is_straight_alpha = OpenAndStripDCTL(dctl_fn)

            -- Call ExtractParameters
            -- Rename parameters and update the Visibility attribute on all DCTL parameters.
            local success, content, params = ExtractParameters(content)

            for i, float_slider_table in pairs(params.float_sliders) do
                UpdateDefault(InpFloatSliders[i], float_slider_table.default_val, time)
            end
            for i, int_slider_table in pairs(params.int_sliders) do
                UpdateDefault(InpIntSliders[i], int_slider_table.default_val, time)
            end
            for i, value_box_table in pairs(params.value_boxes) do
                UpdateDefault(InpValueBoxes[i], value_box_table.default_val, time)
            end
            for i, check_box_table in pairs(params.check_boxes) do
                UpdateDefault(InpCheckBoxes[i], check_box_table.default_val, time)
            end
            for i, combo_box_table in pairs(params.combo_boxes) do
                UpdateDefault(InpComboBoxes[i], combo_box_table.default_val, time)
            end
            for i, color_picker_table in pairs(params.color_pickers) do
                UpdateDefault(InpColorControlReds[i], color_picker_table.red_default, time)
                UpdateDefault(InpColorControlGreens[i], color_picker_table.green_default, time)
                UpdateDefault(InpColorControlBlues[i], color_picker_table.blue_default, time)
            end

            -- If the Rest button is pressed, we only have access to the default parameters in the form
            -- of the INP_Default attribute (not the source code).
            if reset_params then
                print("Resetting params...")
                for i = 0, table_len(InpFloatSliders) - 1 do
                    InpFloatSliders[i]:SetSource(Number(InpFloatSliders[i]:GetAttr("INP_Default")), time)
                end
                for i = 0, table_len(InpIntSliders) - 1 do
                    InpIntSliders[i]:SetSource(Number(InpIntSliders[i]:GetAttr("INP_Default")), time)
                end
                for i = 0, table_len(InpValueBoxes) - 1 do
                    InpValueBoxes[i]:SetSource(Number(InpValueBoxes[i]:GetAttr("INP_Default")), time)
                end
                for i = 0, table_len(InpCheckBoxes) - 1 do
                    InpCheckBoxes[i]:SetSource(Number(InpCheckBoxes[i]:GetAttr("INP_Default")), time)
                end
                for i = 0, table_len(InpComboBoxes) - 1 do
                    InpComboBoxes[i]:SetSource(Number(InpComboBoxes[i]:GetAttr("INP_Default")), time)
                end
                for i = 0, table_len(InpColorControlReds) - 1 do
                    InpColorControlReds[i]:SetSource(Number(InpColorControlReds[i]:GetAttr("INP_Default")), time)
                end
                for i = 0, table_len(InpColorControlGreens) - 1 do
                    InpColorControlGreens[i]:SetSource(Number(InpColorControlGreens[i]:GetAttr("INP_Default")), time)
                end
                for i = 0, table_len(InpColorControlBlues) - 1 do
                    InpColorControlBlues[i]:SetSource(Number(InpColorControlBlues[i]:GetAttr("INP_Default")), time)
                end
            end

            -- Update label and min/max val
            for i, float_slider_table in pairs(params.float_sliders) do
                InpFloatSliders[i]:SetAttrs({
                    LINKS_Name = float_slider_table.label,
                    INP_MinScale = float_slider_table.min_val,
                    INP_MaxScale = float_slider_table.max_val,
                    IC_Visible = true,
                    INPS_StatusText = params.tooltips[float_slider_table.label],
                })
            end
            for i, int_slider_table in pairs(params.int_sliders) do
                InpIntSliders[i]:SetAttrs({
                    LINKS_Name = int_slider_table.label,
                    INP_MinScale = int_slider_table.min_val,
                    INP_MaxScale = int_slider_table.max_val,
                    IC_Visible = true,
                    INPS_StatusText = params.tooltips[int_slider_table.label],
                })
            end
            for i, value_box_table in pairs(params.value_boxes) do
                InpValueBoxes[i]:SetAttrs({
                    LINKS_Name = value_box_table.label,
                    IC_Visible = true,
                    INPS_StatusText = params.tooltips[value_box_table.label],
                })
            end
            for i, check_box_table in pairs(params.check_boxes) do
                InpCheckBoxes[i]:SetAttrs({
                    LINKS_Name = check_box_table.label,
                    IC_Visible = true,
                    INPS_StatusText = params.tooltips[check_box_table.label],
                })
            end
            for i, combo_box_table in pairs(params.combo_boxes) do
                InpComboBoxes[i]:SetAttrs({
                    LINKS_Name = combo_box_table.label,
                    IC_Visible = true,
                    combo_box_table.dropdown_options,
                    INPS_StatusText = params.tooltips[combo_box_table.label],
                })
            end
            for i, color_picker_table in pairs(params.color_pickers) do
                InpColorControlReds[i]:SetAttrs({
                    ICS_Name = color_picker_table.label,
                    IC_Visible = true,
                    INPS_StatusText = params.tooltips[color_picker_table.label],
                })
                InpColorControlGreens[i]:SetAttrs({
                    IC_Visible = true,
                    INPS_StatusText = params.tooltips[color_picker_table.label],
                })
                InpColorControlBlues[i]:SetAttrs({
                    IC_Visible = true,
                    INPS_StatusText = params.tooltips[color_picker_table.label],
                })
            end
        end
        PreviousFn = param.Value
    end
end

function split_arguments(args)
    -- Given a string args like "foo - bar, min(foo, bar)" return a table that splits
    -- this string around commas that aren't in any parentheses or braces.
    local paren_counter = 0
    local start = 1;
    local arg_table = {}
    for i = 1, string.len(args) do
        local curr_char = string.sub(args, i, i)
        if curr_char == "{" or curr_char == "(" then
            paren_counter = paren_counter + 1
        elseif curr_char == "}" or curr_char == ")" then
            paren_counter = paren_counter - 1
        end
        if paren_counter == 0 then
            if i == string.len(args) then
                table.insert(arg_table, string.trim(string.sub(args, start, i)))
                start = i
            elseif curr_char == "," then
                table.insert(arg_table, string.trim(string.sub(args, start, i - 1)))
                start = i + 1
            end
        end
    end
    return arg_table
end

function typecast_builtin_funcs(dctl_source)
    local dctl_source_new = dctl_source
    -- Take the list of built-in functions, Find the ones with float parameters and explicitly cast their parameters to floats.

    local builtins = {"_fabs(float x)", "_logf(float x)", "_log2f(float x)", "_log10f(float x)", "_expf(float x)",
                      "_exp2f(float x)", "_exp10f(float x)", "_saturatef(float x)", "_sqrtf(float x)",
                      "_ceilf(float x)", "_floorf(float x)", "_truncf(float x)", "_round(float x)", "_cosf(float x)",
                      "_sinf(float x)", "_cospif(float x)", "_sinpif(float x)", "_tanf(float x)", "_acosf(float x)",
                      "_asinf(float x)", "_acoshf(float x)", "_asinhf(float x)", "_atanhf(float x)", "_coshf(float x)",
                      "_sinhf(float x)", "_tanhf(float x)", "_rsqrtf(float x)", "_frecip(float x)", "isinf(float x)",
                      "isnan(float x)", "signbit(float x)", "_fmaxf(float x, float y)", "_frexp(float x, int exp)",
                      "_ldexp(float x, int exp)", "_powf(float x, float y)", "_copysignf(float x, float y)",
                      "_fminf(float x, float y)", "_fmod(float x, float y)", "_hypotf(float x, float y)",
                      "_atan2f(float y, float x)", "_fdimf(float x, float y)", "_fdivide(float x, float y)",
                      "_clampf(float x, float min, float max)", "_fmaf(float x, float y, float z)", "abs(int x)",
                      "min(int x, int y)", "max(int x, int y)" -- "T _mix(T x, T y, float a)",
    }
    for i, signature in pairs(builtins) do
        local ret, rhs = 0, 0
        local source_args, source_funcname
        local func_name = string.match(signature, "([%w_]+)%(")
        local arguments = string.match(signature, "%((.+)%)")
        local arg_types = {}
        -- Retrieve expected argument types.
        local i = 1
        for arg_type in string.gmatch(arguments, "([%w]+)%s[^,%)]*") do
            arg_types[i] = arg_type
            i = i + 1
        end
        -- source_funcname will have one extra character prepended to it.
        local signature_pattern = "([^%w_]" .. func_name .. ")(%b())"
        repeat
            ret, rhs, source_funcname, source_args = string.find(dctl_source_new, signature_pattern, rhs)
            if ret ~= nil then
                local original_substr = string.sub(dctl_source_new, ret, rhs)
                -- strip off parentheses
                source_args = source_args:sub(2, source_args:len() - 1)
                -- Get what's passed into the function in the source code.
                local split_source_args = split_arguments(source_args)
                if table_len(split_source_args) ~= table_len(arg_types) then
                    print("ERROR: Incorrect number of arguments for function ", func_name, source_args)
                    return
                end
                -- Add casting operator
                local new_args = ""
                for i = 1, table_len(arg_types) do
                    local separator = ", "
                    if i == 1 then
                        separator = ""
                    end
                    new_args = new_args .. string.format("%s(%s)(%s)", separator, arg_types[i], split_source_args[i])
                end
                -- Inject new function call into the source code.
                local new_funccall = string.format("%s(%s)", source_funcname, new_args)
                dctl_source_new = string.gsub(dctl_source_new, original_substr:gsub('%W', function(x)
                    return '%' .. x
                end), new_funccall, 1)
                rhs = ret + string.len(source_funcname) + 1
            end
        until ret == nil
    end
    return dctl_source_new
end

function rewrite_code(dctl_fn, debug, auto_typecast, img_width, img_height)
    -- TODO: make it so this function isn't called every frame, but only when a new dctl is pulled.
    if debug then
        local original_content = OpenDCTL(dctl_fn)
        print("Original DCTL:")
        print(original_content)
    end

    local preprocessed_content, is_straight_alpha = OpenAndStripDCTL(dctl_fn)

    if auto_typecast then
        preprocessed_content = typecast_builtin_funcs(preprocessed_content)
    end

    -- parse DEFINE_UI_PARAMS
    -- Read parameters via searching for DEFINE_UI_PARAMS, skip commented out ones.
    local success, preprocessed_content, params = ExtractParameters(preprocessed_content)
    if success == false then
        return
    end
    local num_float_sliders = table_len(params.float_sliders)
    local num_int_sliders = table_len(params.int_sliders)
    local num_value_boxes = table_len(params.value_boxes)
    local num_check_boxes = table_len(params.check_boxes)
    local num_combo_boxes = table_len(params.combo_boxes)
    local num_color_pickers = table_len(params.color_pickers)
    if debug then
        print(string.format("Found %d float sliders", num_float_sliders))
        print(string.format("Found %d int sliders", num_int_sliders))
        print(string.format("Found %d value boxes", num_value_boxes))
        print(string.format("Found %d check boxes", num_check_boxes))
        print(string.format("Found %d combo boxes", num_combo_boxes))
        print(string.format("Found %d color pickers", num_color_pickers))
    end
    local param_counts = {
        num_float_sliders = num_float_sliders,
        num_int_sliders = num_int_sliders,
        num_value_boxes = num_value_boxes,
        num_check_boxes = num_check_boxes,
        num_combo_boxes = num_combo_boxes,
        num_color_pickers = num_color_pickers
    }

    local dctl_parameters = string.format([[
        float float_slider_params[%d];
        int int_slider_params[%d];
        float value_box_params[%d];
        int check_box_params[%d];
        int combo_box_params[%d];
        float color_picker_params[%d][3];
        int timeline_frame_index;
        ]], math.max(1, num_float_sliders), math.max(1, num_int_sliders), math.max(1, num_value_boxes),
        math.max(1, num_check_boxes), math.max(1, num_combo_boxes), math.max(1, num_color_pickers))

    if debug then
        print("Parameter Struct: ")
        print(dctl_parameters)
    end

    -- Inject parameters to code by just adding more parameters to the Transform function.
    local transform_extra_params = ""
    local transform_parameter_declarations = ""
    for i, float_slider in pairs(params.float_sliders) do
        transform_extra_params = transform_extra_params .. string.format(", params->float_slider_params[%d]", i)
        transform_parameter_declarations = transform_parameter_declarations ..
                                               string.format(", float %s", float_slider.var_name)
    end
    for i, int_slider in pairs(params.int_sliders) do
        transform_extra_params = transform_extra_params .. string.format(", params->int_slider_params[%d]", i)
        transform_parameter_declarations = transform_parameter_declarations ..
                                               string.format(", int %s", int_slider.var_name)
    end
    for i, value_box in pairs(params.value_boxes) do
        transform_extra_params = transform_extra_params .. string.format(", params->value_box_params[%d]", i)
        transform_parameter_declarations = transform_parameter_declarations ..
                                               string.format(", float %s", value_box.var_name)
    end
    for i, check_box in pairs(params.check_boxes) do
        transform_extra_params = transform_extra_params .. string.format(", params->check_box_params[%d]", i)
        transform_parameter_declarations = transform_parameter_declarations ..
                                               string.format(", int %s", check_box.var_name)
    end
    for i, combo_box in pairs(params.combo_boxes) do
        transform_extra_params = transform_extra_params .. string.format(", params->combo_box_params[%d]", i)
        transform_parameter_declarations = transform_parameter_declarations ..
                                               string.format(", int %s", combo_box.var_name)
    end
    for i, color_picker in pairs(params.color_pickers) do
        transform_extra_params = transform_extra_params .. string.format(
            ", __make_DCTLColorPickerParam(params->color_picker_params[%d][0], params->color_picker_params[%d][1], params->color_picker_params[%d][2])",
            i, i, i)
        transform_parameter_declarations = transform_parameter_declarations ..
                                               string.format(", DCTLColorPickerParam %s", color_picker.var_name)
    end
    transform_extra_params = transform_extra_params .. ", params->timeline_frame_index"
    transform_parameter_declarations = transform_parameter_declarations .. ", const int TIMELINE_FRAME_INDEX"

    -- Replace transform function with augmented one with new parameters.
    local local_transform_function_pattern =
        "__DEVICE__%s*float3%s*transform%(int%s+p_Width,%s*int%s+p_Height,%s*int%s+p_X,%s*int%s+p_Y,%s*float%s+p_R,%s*float%s+p_G,%s*float%s+p_B%)"
    local new_local_transform_function_signature = string.format(
        "__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B%s)",
        transform_parameter_declarations)
    local local_transform_function_call = string.format("transform(p_Width, p_Height, p_X, p_Y, p_R, p_G, p_B%s)",
        transform_extra_params)
    local res1 = string.find(preprocessed_content, local_transform_function_pattern)

    local texture_transform_function_pattern =
        "__DEVICE__%s*float3%s*transform%(int%s+p_Width,%s*int%s+p_Height,%s*int%s+p_X,%s*int%s+p_Y,%s*__TEXTURE__%s+p_TexR%s*,%s*__TEXTURE__%s+p_TexG%s*,%s*__TEXTURE__%s+p_TexB%s*%)"
    local new_texture_transform_function_signature = string.format(
        "__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB%s)",
        transform_parameter_declarations)
    local texture_transform_function_call = string.format(
        "transform(p_Width, p_Height, p_X, p_Y, p_TexR, p_TexG, p_TexB%s)", transform_extra_params)
    local res2 = string.find(preprocessed_content, texture_transform_function_pattern)

    local local_transform_alpha_function_pattern =
        "__DEVICE__%s*float4%s*transform%(int%s+p_Width,%s*int%s+p_Height,%s*int%s+p_X,%s*int%s+p_Y,%s*float%s+p_R,%s*float%s+p_G,%s*float%s+p_B,%s*float%s+p_A%)"
    local new_local_transform_alpha_function_signature = string.format(
        "__DEVICE__ float4 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B, float p_A%s)",
        transform_parameter_declarations)
    local local_transform_alpha_function_call = string.format(
        "transform(p_Width, p_Height, p_X, p_Y, p_R, p_G, p_B, p_A%s)", transform_extra_params)
    local res3 = string.find(preprocessed_content, local_transform_alpha_function_pattern)

    local texture_transform_alpha_function_pattern =
        "__DEVICE__%s*float4%s*transform%(int%s+p_Width,%s*int%s+p_Height,%s*int%s+p_X,%s*int%s+p_Y,%s*__TEXTURE__%s+p_TexR%s*,%s*__TEXTURE__%s+p_TexG%s*,%s*__TEXTURE__%s+p_TexB%s*,%s*__TEXTURE__%s+p_TexA%s*%)"
    local new_texture_transform_alpha_function_signature = string.format(
        "__DEVICE__ float4 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB, __TEXTURE__ p_TexA%s)",
        transform_parameter_declarations)
    local texture_transform_alpha_function_call = string.format(
        "transform(p_Width, p_Height, p_X, p_Y, p_TexR, p_TexG, p_TexB, p_TexA%s)", transform_extra_params)
    local res4 = string.find(preprocessed_content, texture_transform_alpha_function_pattern)

    local transform_function_pattern
    local transform_function_signature
    local transform_function_call
    local channel_declarations
    local has_alpha = false
    local texture_declarations_required = false
    if res1 ~= nil and res2 == nil and res3 == nil and res4 == nil then
        transform_function_pattern = local_transform_function_pattern
        transform_function_signature = new_local_transform_function_signature
        transform_function_call = local_transform_function_call
        channel_declarations = [[

    float4 __RGBA = _tex2DVec4(inputTexture, X, Y);
    float p_R = __RGBA.x;
    float p_G = __RGBA.y;
    float p_B = __RGBA.z;]]
    elseif res1 == nil and res2 ~= nil and res3 == nil and res4 == nil then
        texture_declarations_required = true
        transform_function_pattern = texture_transform_function_pattern
        transform_function_signature = new_texture_transform_function_signature
        transform_function_call = texture_transform_function_call
        -- Declare p_TexR/g/b in the kernel.
        channel_declarations = [[

    __TEXTURESTRUCT__ p_TexR = {inputTexture, 8, p_Width, p_Height};
    __TEXTURESTRUCT__ p_TexG = {inputTexture, 4, p_Width, p_Height};
    __TEXTURESTRUCT__ p_TexB = {inputTexture, 2, p_Width, p_Height};]]
    elseif res1 == nil and res2 == nil and res3 ~= nil and res4 == nil then
        transform_function_pattern = local_transform_alpha_function_pattern
        transform_function_signature = new_local_transform_alpha_function_signature
        transform_function_call = local_transform_alpha_function_call
        has_alpha = true
        channel_declarations = [[

    float4 __RGBA = _tex2DVec4(inputTexture, X, Y);
    float p_R = __RGBA.x;
    float p_G = __RGBA.y;
    float p_B = __RGBA.z;
    float p_A = __RGBA.w;]]
    elseif res1 == nil and res2 == nil and res3 == nil and res4 ~= nil then
        texture_declarations_required = true
        transform_function_pattern = texture_transform_alpha_function_pattern
        transform_function_signature = new_texture_transform_alpha_function_signature
        transform_function_call = texture_transform_alpha_function_call
        has_alpha = true
        -- Declare p_TexR/g/b in the kernel.
        channel_declarations = [[

    __TEXTURESTRUCT__ p_TexR = {inputTexture, 8, p_Width, p_Height};
    __TEXTURESTRUCT__ p_TexG = {inputTexture, 4, p_Width, p_Height};
    __TEXTURESTRUCT__ p_TexB = {inputTexture, 2, p_Width, p_Height};
    __TEXTURESTRUCT__ p_TexA = {inputTexture, 1, p_Width, p_Height};]]
    elseif res1 == nil and res2 == nil and res3 == nil and res4 == nil then
        print("ERROR: Could not find transform function.")
        return
    else
        print("ERROR: Found multiple transform functions.")
        return
    end

    -- String that runs the function call and converts it to a float4 __RGBA_OUT
    local transform_function_call_return
    if has_alpha then
        if is_straight_alpha then
            -- Straight alpha
            transform_function_call_return = string.format([[

    float4 __RGBA_OUT = %s;]], transform_function_call)
        else
            -- TODO: This behavior may change as Resolve unifies Fusion and Resolve DCTL tools.
            -- Premultiply
            transform_function_call_return = string.format([[

    p_R = p_R * p_A;
    p_G = p_G * p_A;
    p_B = p_B * p_A;
    float4 __RGBA_OUT = %s;
    __RGBA_OUT.x = __RGBA_OUT.x / __RGBA_OUT.w;
    __RGBA_OUT.y = __RGBA_OUT.y / __RGBA_OUT.w;
    __RGBA_OUT.z = __RGBA_OUT.z / __RGBA_OUT.w;]], transform_function_call)
        end
    else
        -- No alpha
        transform_function_call_return = string.format([[

    float3 __RGB = %s;
    float4 __RGBA_OUT = make_float4(__RGB.x, __RGB.y, __RGB.z, 1.0);]], transform_function_call)
    end

    preprocessed_content = string.gsub(preprocessed_content, transform_function_pattern, transform_function_signature)

    -- Stuff that goes at the top of the file.
    if texture_declarations_required then
        -- inject __TEXTURE__ type declaration at the top of the code.
        -- This will be done by making a wrapper struct that stores a __TEXTURE2D__ and an integer that indicates the channel.
        local texture_declaration = [[
typedef struct {
    __TEXTURE2D__ tex;
    int index;
    int width, height;
} __TEXTURESTRUCT__;

__DEVICE__ float __tex2D_override(__TEXTURESTRUCT__ ptex, int x, int y) {
    float4 out = _tex2DVec4(ptex.tex, x, (ptex.height - 1) - y);
    if (ptex.index & 1) {
        return out.w;
    }
    if (ptex.index & 1 << 1) {
        return out.z;
    }
    if (ptex.index & 1 << 2) {
        return out.y;
    }
    if (ptex.index & 1 << 3) {
        return out.x;
    }
    return -1.0;
}
        ]]
        preprocessed_content = string.insert(preprocessed_content, texture_declaration, 0)

        -- All instances of __TEXTURE__ will then be replaced with the wrapper struct and the appropriate values will have to be passed
        preprocessed_content = string.gsub(preprocessed_content, "__TEXTURE__", "__TEXTURESTRUCT__")

        -- Then we will replace all _tex2d calls in the original source code with _tex2DVecN with the appropriate value passed in.
        preprocessed_content = string.gsub(preprocessed_content, "_tex2D%s*%(", "__tex2D_override(")
    end

    if param_counts.num_color_pickers > 0 then
        local color_picker_type_declarations = [[
typedef struct {
    float r;
    float g;
    float b;
} DCTLColorPickerParam;

__DEVICE__ DCTLColorPickerParam __make_DCTLColorPickerParam(float r, float g, float b) {
    DCTLColorPickerParam out = {};
    out.r = r;
    out.g = g;
    out.b = b;
    return out;
}]]
        preprocessed_content = string.insert(preprocessed_content, color_picker_type_declarations, 0)
    end

    if string.find(preprocessed_content, "RAND") ~= nil then
        local rand_declaration = [[
__DEVICE__ float RAND(uint seed) {
    uint x = seed;
    x *= 694206942069;
    x ^= (x << 16 | x >> 16);
    x += 694206942069;
    x ^= (x << 13 | x >> 19);
    x ^= (x >> 17 | x << 15);
    x ^= (x << 5 | x >> 27);
    x -= 694206942069;
    x ^= (x << 11 | x >> 21);
    x ^= (x >> 7 | x << 25);
    x ^= (x << 6 | x >> 26);
    x ^= 694206942069;
    return (((float)x) / (float)(~((uint)0)));
}
        ]]
        preprocessed_content = string.insert(preprocessed_content, rand_declaration, 0)
    end

    -- Rename kernel so that each dctl has a unique kernel. This fixes a bug with Fusion caching where
    -- multiple DCTL Interpreters in a row would be broken.
    local kernel_name = self.Name .. string.gsub(string.gsub(dctl_fn, "%.dctl", ""), "[^%w]", "__")
    local parameters_name = kernel_name .. "_parameters_t"
    -- We'll append the necessary kernel function to the bottom of the DCTL, and we'll call the DCTL's transform function.
    local kernel_function_str = string.format([[
__KERNEL__ void %s(__CONSTANTREF__ %s *params, __TEXTURE2D__ inputTexture, __TEXTURE2D_WRITE__ outputTexture) {
    int p_Width = %s;
    int p_Height = %s;
    DEFINE_KERNEL_ITERATORS_XY(X, Y)
    int p_X = X;
    int p_Y = (p_Height - 1) - Y;
    %s
    %s
    _tex2DVec4Write(outputTexture, X, Y, __RGBA_OUT);
}]], kernel_name, parameters_name, img_width, img_height, channel_declarations, transform_function_call_return)
    preprocessed_content = preprocessed_content .. "\n" .. kernel_function_str

    -- Improve formatting for console.
    preprocessed_content = string.gsub(preprocessed_content, "\n%s*\n", "\n")
    if debug then
        print("Resulting Source Code:")
        print(preprocessed_content)
    end

    return kernel_name, preprocessed_content, parameters_name, dctl_parameters, param_counts
end

function Process(req)
    local img = InImage:GetValue(req)
    local dctl_fn = DCTLFile:GetValue(req).Value
    local debug = DebugBox:GetValue(req).Value > 0.5
    local auto_typecast = AutoTypecast:GetValue(req).Value > 0.5
    local dont_run = DontRun:GetValue(req).Value > 0.5

    if dctl_fn == nil or dctl_fn == "" then
        OutImage:Set(req, img)
    elseif not req:IsPreCalc() then
        local kernel_name, preprocessed_content, parameters_name, dctl_parameters, param_counts = rewrite_code(dctl_fn,
            debug, auto_typecast, img.Width, img.Height)

        if dont_run then
            OutImage:Set(req, img)
        else
            local out = Image({
                IMG_Like = img
            })
            local node = DVIPComputeNode(req, kernel_name, preprocessed_content, parameters_name, dctl_parameters)
            node:AddInput("inputTexture", img)
            node:AddOutput("outputTexture", out)

            -- Populate dctl_parametersRef once we started parsing parameters.
            local paramsRef = node:GetParamBlock(dctl_parameters)
            for i = 0, param_counts.num_float_sliders - 1 do
                paramsRef.float_slider_params[i] = InpFloatSliders[i]:GetValue(req).Value
            end
            for i = 0, param_counts.num_int_sliders - 1 do
                paramsRef.int_slider_params[i] = InpIntSliders[i]:GetValue(req).Value
            end
            for i = 0, param_counts.num_value_boxes - 1 do
                paramsRef.value_box_params[i] = InpValueBoxes[i]:GetValue(req).Value
            end
            for i = 0, param_counts.num_check_boxes - 1 do
                paramsRef.check_box_params[i] = InpCheckBoxes[i]:GetValue(req).Value
            end
            for i = 0, param_counts.num_combo_boxes - 1 do
                paramsRef.combo_box_params[i] = InpComboBoxes[i]:GetValue(req).Value
            end
            for i = 0, param_counts.num_color_pickers - 1 do
                paramsRef.color_picker_params[i][0] = InpColorControlReds[i]:GetValue(req).Value
                paramsRef.color_picker_params[i][1] = InpColorControlGreens[i]:GetValue(req).Value
                paramsRef.color_picker_params[i][2] = InpColorControlBlues[i]:GetValue(req).Value
            end
            paramsRef.timeline_frame_index = req.Time
            node:SetParamBlock(paramsRef)

            success = node:RunSession(req)
            OutImage:Set(req, out)
        end
    end
end
